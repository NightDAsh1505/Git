# Git
"Вивчення Git"

Мета: Опанувати базові команди та принципи роботи з системою контролю версій Git, шляхом проходження курсу на githowto.com.

1. Найперше, що повинно бути виконано це декілька команд, щоб Git дізнався ім'я та електронну пошту. Ці дані використовуються для підпису змін, що дозволить відстежувати, хто і коли зробив зміни в файлі.

![1.1](screens1/1.1.jpg)

Перший рядок про ім’я.

Другий рядок про пошту.

Третій рядок - налаштовання початкової гілки за замовчуванням, в цьому випадку це main.

Четвертий рядок - забезпечує автоматичну конвертацію кінцівок рядків між форматами CRLF і LF під час коміту і checkout, щоб зробити їх однорідними у репозиторії, особливо у крос-платформних проєктах.

П’ятий рядок - встановлює Git на попередження про потенційні проблеми з кінцівками рядків (змішані кінцівки), що може допомогти уникнути проблем з файлом у репозиторії.

Ці конфігурації допомагають забезпечити узгодженість форматів кінцівок рядків у репозиторії та попередити можливі проблеми під час роботи з файлами на різних операційних системах.

![1.2](screens1/1.2.jpg)

Команда cat .gitconfig використовується для виведення вмісту файлу .gitconfig.

2. Створення проєкту

Для початку створюємо порожню піддиректорію work:

![2.1](screens1/2.1.jpg)

потім переходимо до неї: 

![2.2](screens1/2.2.jpg)

та створюємо файл hello.html:

![2.3](screens1/2.3.jpg)

Відкриваємо файл у редакторі nano:

![2.4](screens1/2.4.jpg)

І вводимо вміст «Hello, World».

Наразі є директорія з одним файлом. Для того щоб створити Git-репозиторій з цієї директорії, слід виконати команду git init:

![2.5](screens1/2.5.jpg)

Повідомлення каже про успішне створення Git-репозиторію.

Далі додаємо в репозитарій сторінку «hello.html»:

![2.6](screens1/2.6.jpg)

Потім створюємо коміт, -m дозволяє вказати повідомлення коміту — "Initial commit":

![2.7](screens1/2.7.jpg)

Слідом випливає повідомлення:
main: назва гілки. За замовчуванням, перша гілка у Git називається main.

(root-commit): вказує на те, що цей коміт є кореневим комітом (root commit), тобто першим комітом в історії цього репозиторію.

с61е77е:  перші сім символів хешу коміту (унікальний ідентифікатор коміту).

1 file changed: Вказує, що один файл (hello.html) був змінений або доданий.

3. Перевірка стану

Щоб дізнатися поточний стан репозиторія потрібно використовувати команду git status:

![3.1](screens1/3.1.jpg)

Команда перевірки стану повідомила, що комітити нема чого. Це означає, що у репозиторії вже зберігається поточний стан робочих файлів, та нема жодних змін, які б могли очікувати на запис.

4. Внесення змін

Відкриваємо файл у редакторі nano:

![4.1](screens1/4.1.jpg)

І змінюємо вміст:

![4.2](screens1/4.2.jpg)

Перевіряємо стан:

![4.3](screens1/4.3.jpg)

Файл було змінено, але ці зміни ще не зафіксовано у репозиторії.

5. Індексація змін

Наступним кроком буде дати команду Git проіндексувати зміни і слідом перевірити стан:

![5.1](screens1/5.1.jpg)

Повідомлення нам переказує, що зміни файлу hello.html було проіндексовано. Тобто Git знає про зміни.

7. Коміт змін

Тепер зробімо коміт того, що проіндексували у репозиторій.

Вводимо команду git commit, але без –m як це було раніше. Тоді нас переносить у редактор:

![7.1](screens1/7.1.jpg)

У першому рядку вводимо коментар Added h1 tag. Зберігаємо і виходимо:

![7.2](screens1/7.2.jpg)
![7.3](screens1/7.3.jpg)

Далі перевіряємо стан:

![7.4](screens1/7.4.jpg)

Бачимо що директорія чиста.

8. Зміни, а не файли

Знову змінюємо вміст файлу:

![8.2](screens1/8.2.jpg)

Тепер додаємо ці зміни в індекс Git:

![8.3](screens1/8.3.jpg)

І знову змінюємо файл, додаючи заголовок:

![8.4](screens1/8.4.jpg)

Перевіряємо статус:

![8.5](screens1/8.5.jpg)

Повідомлення показує що файл згадано двічі. Перша зміна проіндексована і готова до коміту. Друга зміна (де додали заголовки) є непроіндексована.

Якби зараз було зроблено коміт, заголовки не було б збережено у репозиторій. Це можна перевірити.

Робимо коміт проіндексованих змін і ще раз перевіряємо стан:

![8.6](screens1/8.6.jpg)

Команда статусу повідомляє, що у файлі досі є незбережені зміни.

Додаємо другу зміну в індекс (перший рядок означає що було використано поточну директорію) і знову перевіряємо стан:

![8.7](screens1/8.7.jpg)

Тепер ми бачимо що другу зміну було проіндексовано й приготовлено до коміту.
Тому далі робимо коміт цієї ж другої зміни:

![8.8](screens1/8.8.jpg)

9. Історія проєкту

За допомогою наступної команди можна отримати список зроблених змін:

![9.1](screens1/9.1.jpg)

Наступна команда відображає однорядковий формат:

![9.2](screens1/9.2.jpg)

Ще декілька варіантів для перегляду історії:

![9.3](screens1/9.3.jpg)

Історія за останній тиждень:

![9.4](screens1/9.4.jpg)

Для того щоб зберегти формат перегляду історії вводимо команди:

![9.5](screens1/9.5.jpg)

10. Отримання старих версій

Використовуємо хеш першого коміту в наступній команді:

![10.1](screens1/10.1.jpg)

Повернімося до останньої версії коду, перемикаючись на гілку за замовчуванням main, за допомогою команди нижче, і перевіримо вміст файлу:

![10.2](screens1/10.2.jpg)

11. Створення тегів версій

Створимо тег поточної версії:

![11.1](screens1/11.1.jpg)

Потім тег для версії, що передує поточній. Але спершу перемкнемося на попередню версію. Замість пошуку хеша коміта, використаємо ^, а саме v1^, що вказує на коміт, попередній до v1:

![11.2](screens1/11.2.jpg)

Це версія яка без заголовка. Позначемо її як v1-beta:

![11.3](screens1/11.3.jpg)

Тепер спробуємо перемикатися між двома версіями:

![11.4](screens1/11.4.jpg)

Подивитись які теги доступні можна використовуючи команду нижче:

![11.5](screens1/11.5.jpg)

Також можна подивитися їх за допомогою команди для виведення списку комітів:

![11.6](screens1/11.6.jpg)

Повідомлення показує теги у лозі разом з ім’ям гілки. Позначка HEAD показує коміт на який ми перемкнулися.

12. Скасування локальних змін (до індексації)

Спершу переконаємося, що перебуваємо на останньому коміті:

![12.1](screens1/12.1.jpg)

Знову змінемо вміст файла hello.html:

![12.2](screens1/12.2.jpg)

Перевіряємо стан:

![12.3](screens1/12.3.jpg)

І бачимо, що файл було змінено, але ще не проіндексовано.

Використаємо команду для перемикання checkout в версію файлу hello.html у репозиторії:

![12.4](screens1/12.4.jpg)

Статус показує, що в робочій директорії не було зроблено жодних незафіксованих змін. І «небажаний коментар» більше не є частиною вмісту файлу.

13. Скасування проіндексованих змін (перед комітом)

Насамперед внесемо зміни у файл hello.html у вигляді небажаного коментаря:

![13.1](screens1/13.1.jpg)

І проіндексуємо ці зміни:

![13.2](screens1/13.2.jpg)

Перевіряємо стан:

![13.3](screens1/13.3.jpg)

І бачимо, що зміни проіндексовано і готове до коміту.

Тепер скасуємо індексацію змін:

![13.4](screens1/13.4.jpg)

Команда reset відкочує область підготовки до HEAD. Це очищає область підготовки від змін, які були проіндексовані. Проте, через те що ця команда не змінює робочу директорію, робоча директорія все ще містить небажаний коментар.

Щоб видалити небажані зміни в робочій директорії використовуємо команду нижче:

![13.5](screens1/13.5.jpg)

Результат:

![13.6](screens1/13.6.jpg)

14. Скасування комітів

Знову змінюємо вміст файлу:

![14.1](screens1/14.1.jpg)

І робимо коміт:

![14.2](screens1/14.2.jpg)

Для скасування коміту, нам необхідно зробити коміт, що видаляє зміни, збережені небажаним комітом.

Вводимо git revert HEAD і переходимо до редактора:

![14.3](screens1/14.3.jpg)

![14.4](screens1/14.4.jpg)

Перевіряємо лог, що показує небажані та скасовані коміти у нашому репозиторії:

![14.5](screens1/14.5.jpg)

15. Видалення комітів з гілки (revert)

Перевіримо історю комітів:

![15.1](screens1/15.1.jpg)

Видалімо два останні коміти за допомогою команди reset.

Але спершу позначемо останній коміт тегом, для зручного пошуку:

![15.2](screens1/15.2.jpg)

Повідомлення логу показує, що коміт з тегом v1 є попереднім комітом до помилкового.

Скиньмо гілку до цієї точки. Оскільки гілка має тег, ми можемо використовувати ім'я тегу в команді відкоту reset (якщо вона не має тега, ми можемо використовувати хеш коміта).

![15.3](screens1/15.3.jpg)

--hard – параметр аби повністю скинути стан робочої директорії до того, як було вказано в зазначеному коміті (у цьому випадку, до тега v1).
В лозі бачимо що вже немає комітів "Revert Oops" і "Oops".

Але якщо ми подивимось на всі коміти то побачимо що помилкові коміти не зникли, вони просто відсутні в гілці main:

![15.4](screens1/15.4.jpg)

16. Видалення тегу Oops

Після видалення більше не буде відображатися у репозиторії:

![16.1](screens1/16.1.jpg)

17. Внесення змін до комітів

Додаємо коментар у сторінку:

![17.1](screens1/17.1.jpg)

І робимо коміт:

![17.2](screens1/17.2.jpg)

Проте після створення коміту ми згадали про електронну пошту автора, яку не вписали, оновлюємо сторінку, додаючи email:

![17.3](screens1/17.3.jpg)

Змінимо попередній коміт, включивши в нього email:

![17.4](screens1/17.4.jpg)

І переглянемо історію для перевірки:

![17.5](screens1/17.5.jpg)

Бачимо як коміт змінений.

18. Створення гілки

Далі ми створемо нову гілку (для CSS) та одночасно перейдемо на неї:

![18.1](screens1/18.1.jpg)

Створемо файл:

![18.2](screens1/18.2.jpg)

І змінемо його вміст:

![18.3](screens1/18.3.jpg)

![18.4](screens1/18.4.jpg)

Потім змінемо вміст hello.html:

![18.5](screens1/18.5.jpg)

![18.6](screens1/18.6.jpg)

Наразі у нас є нова гілка (style) з двома новими комітами.

19. Перемикання гілок

Перевіримо в лозі:

![19.1](screens1/19.1.jpg)

Перемикаємося на гілку main і відображуємо вміст файлу hello.html:

![19.2](screens1/19.2.jpg)

Зараз ми знаходимося у гілці main і бачимо що у файлі hello.html немає style.css, бо ми їх не бачимо з гілки main.

Повертаємося до гілки style і відображуємо вміст файлу hello.html:

![19.3](screens1/19.3.jpg)

І ми бачимо шо наші зміни присутні.

20. Переміщення файлів

Перевіряємо історію змін окремо у файлі hello.html і у файлі style.css:

![20.1](screens1/20.1.jpg)

Команда show використовується для перегляду змін у конкретному коміті: 

![20.2](screens1/20.2.jpg)

diff --git a/hello.html b/hello.html - показує, що порівнюються дві версії файлу hello.html (до і після змін).

@@ -1,4 +1,6 @@ - показує контекст змін: починаючи з першого рядка, у старій версії було 4 рядки, а у новій - 6 рядків.

Рядки, позначені +, є новими і були додані в цьому коміті.

Наступним кроком буде перейменувати файл hello.html на index.html за допомогою стандартної команди mv:

![20.3](screens1/20.3.jpg)

Git розуміє цю зміну так, ніби файл було видалено і створено новий. Нам потрібно повідомити Git, що ми саме перейменували файл, а не видалили та створили новий. 

Але в простих ситуаціях Git сам зрозуміє, що файл було перейменовано, щойно ми додамо його до індексу:

![20.4](screens1/20.4.jpg)

Потім перемістимо наш файл style.css до директорії css, але цього разу зробимо це безпечно за допомогою команди git mv.

Ця команда гарантує, що переміщення буде записано в історії Git як переміщення:

![20.5](screens1/20.5.jpg)

Потім закомітимо та перевіримо історію змін у файлі css/styles.css. Нам потрібно буде додати опцію --follow, щоб побачити історію файлу до того, як він був переміщений:

![20.6](screens1/20.6.jpg)

21. Зміни в гілці main

Створимо файл README:

![21.1](screens1/21.1.jpg)

і впишемо в ньому наступне:

![21.2](screens1/21.2.jpg)

Далі треба закомітити файл README у гілку main, однак зараз ми перебуваємо у гілці style. Файл README не є частиною цієї гілки, тому перед комітом слід перейти до гілки main:

![21.3](screens1/21.3.jpg)

22. Перегляд розбіжних гілок

Тепер у репозиторії є дві гілки, що розходяться. За допомогою наступною командою log, можна побачити гілки і те, як вони розходяться:

![22.1](screens1/22.1.jpg)

Опція --all гарантує, що ми бачимо всі гілки, оскільки за замовчуванням у лозі показується тільки поточна гілка.

Опція --graph додає просте дерево комітів, зображене текстовими лініями. Ми бачимо обидві гілки (style і main) і те, що гілка main відмічена як HEAD, тобто вона є поточною. Спільним предком для обох гілок є гілка, у якій було внесено коміт «Added copyright statement with email».

23. Злиття

Злиття переносить зміни з двох гілок в одну. Повернемося до гілки style і зіллємо main із style:

![23.1](screens1/23.1.jpg)

![23.2](screens1/23.2.jpg)

І перевіряємо стан:

![23.3](screens1/23.3.jpg)

24. Створення конфлікту

Для початку повернімося до гілки main і впишемо зміни:

![24.1](screens1/24.1.jpg)

![24.2](screens1/24.2.jpg)

![24.3](screens1/24.3.jpg)

Переглянемо гілки:

![24.4](screens1/24.4.jpg)

Після коміту «Added README» гілка main була об'єднана з гілкою style, але зараз в main є додатковий коміт, що не був злитий із style. Також можемо побачити що остання зміна в main конфліктує з деякими змінами в style.

25. Вирішення конфліктів

Повернемося до гілки style і зіллємо туди всі нещодавні зміни з гілки main:

![25.1](screens1/25.1.jpg)

Повідомлення сповіщає про конфлікт.

Перевіряємо стан:

![25.2](screens1/25.2.jpg)

При відкритті index.html в редакторі випливає наступне:

![25.3](screens1/25.3.jpg)

Частина між <<<<<<< >>>>>>> є конфліктом. Секція зверху відповідає гілці style, що є поточною гілкою (або HEAD) репозиторія. Нижня секція відповідає змінам з гілки main. Git не може вирішити, які зміни застосовувати, тому просить розв'язати конфлікт вручну. 

Перш ніж розв'язувати конфлікт. Git дозволяє скасувати злиття і відновити попередній стан репозиторія. Для цього можна скористатися командою git merge --abort, як це було запропоновано командою status, яку щойно виконали:

![25.4](screens1/25.4.jpg)

Далі ще раз запустимо злиття:

![25.5](screens1/25.5.jpg)

Відредагуємо файл до стану, який нас влаштовує, а потім закомітимо його. У цьому випадку об'єднаємо зміни з обох гілок. 

Отже, редагуємо файл до наступного стану:

![25.6](screens1/25.6.jpg)

Зробимо коміт з розв'язаним конфліктом:

![25.7](screens1/25.7.jpg)

І подивимося на поточний стан нашого репозиторію і переконаємось, що все гаразд:

![25.8](screens1/25.8.jpg)

27. Відкочування гілки style

Слід повернутись у гілку style до точки перед тим, як ми злили її з гілкою main. Можемо відновити гілку до будь-якого коміту за допомогою команди reset.

У цьому випадку ми хочемо повернутися в гілці style в точку перед злиттям з main. Нам необхідно знайти останній коміт перед злиттям:

![27.1](screens1/27.1.jpg)

Повідомлення пише, що коміт «Renamed hello.html; moved style.css» був останнім у гілці style перед злиттям.

Далі скидаємо гілку style до цього коміту. Для посилання на цей коміт ми визначаємо, що цей коміт знаходиться за 2 коміти до HEAD, тобто HEAD~2 у нотації Git.

![27.2](screens1/27.2.jpg)

Тепер перевіримо історію змін у гілці style:

![27.3](screens2/27.3.jpg)

У ньому не повинно бути жодних комітів злиття.

28. Перебазування

Ми повернули гілку style до стану перед першим злиттям. В гілці main є дві коміти, яких зараз немає у гілці style: новий файл README і конфліктна зміна у файлі index.html. Цього разу треба перенести ці зміни до гілки style за допомогою команди rebase, а не merge.

Спершу перебазуємо гілку style на main:

![28.1](screens2/28.1.jpg)

Бачимо що знову виник конфлікт, що стався в hello.html, а не в index.html, як минулого разу. Це тому, що rebase був у процесі застосування змін style поверх гілки main. У той момент в гілці main ще не було перейменовано файл hello.html, тому він все ще має стару назву.

При злитті виник би "зворотній" конфлікт. Під час злиття зміни гілки main були б застосовані поверх гілки style. У гілці style файл перейменовано, тому конфлікт виник би у файлі index.html:

![28.2](screens2/28.2.jpg)

По-перше, редагуємо файл hello.html так як треба:

![28.3](screens2/28.3.jpg)

Але після цього не потрібно комітити зміни. Можемо просто додати файл до індексу і продовжити процес перебазування.

![28.4](screens2/28.4.jpg)

![28.5](screens2/28.5.jpg)

Потім перевіряємо:

![28.6](screens2/28.6.jpg)

Кінцевий результат перебазування дуже схожий на результат злиття. Гілка style зараз містить всі свої зміни, а також всі зміни гілки main. Однак, дерево комітів значно відрізняється. Дерево комітів гілки style було переписано таким чином, що гілка main є частиною історії комітів. Це робить ланцюг комітів лінійним і набагато більш читабельним.

29. Злиття в гілку main

Виконуємо злиття style в main:

![29.1](screens2/29.1.jpg)

І потім переглядаємо логи:

![29.2](screens2/29.2.jpg)

Тепер гілки style і main ідентичні.

<h1>Частина 2: Декілька репозиторіїв</h1>

30. Клонування репозиторіїв

Перейдімо в директорію repositories:

![30.1](screens2/30.1.jpg)

У цей момент ми повинні знаходитися в директорії repositories. Тут має бути єдиний репозиторій під назвою work.

Далі створимо клон репозиторія work:

![30.2](screens2/30.2.jpg)

У списку репозиторіїв тепер має бути два репозиторія: оригінальний репозиторій work і клонований репозиторій home.

31. Перегляд клонованого репозиторія

Подивимось на клонований репозиторій:

![31.1](screens2/31.1.jpg)

Переглядаємо історію репозиторія:

![31.2](screens2/31.2.jpg)

Бачимо список всіх комітів у новий репозиторій, і він повинен збігатися з історією комітів в оригінальному репозиторії. Єдина різниця повинна бути в назвах гілок.

32. Що таке origin?

Переглянемо список віддалених репозиторіїв, які налаштовані для локального Git-репозиторію:

![32.1](screens2/32.1.jpg)

Бачимо, що клонований репозиторій знає про ім'я за замовчуванням віддаленого репозиторія.

Подивимось, чи можемо отримати більш детальну інформацію про ім'я за замовчуванням:

![32.2](screens2/32.2.jpg)

Бачимо, що «ім'я за замовчуванням» віддаленого репозиторія — початкове work. 

33. Віддалені гілки

Подивимось на гілки, доступні в нашому клонованому репозиторії:

![33.1](screens2/33.1.jpg)

У списку лише гілка main, бо команда git branch, за замовчуванням, виводить лише список локальних гілок.

Для того, щоб побачити всі гілки, введемо наступну команду:

![33.2](screens2/33.2.jpg)

Git виводить всі коміти в оригінальний репозиторій, але гілки в віддаленому репозиторії не розглядаються як локальні.

34. Зміна оригінального репозиторія

Перейдемо в оригінальний репозиторій work:

![34.1](screens2/34.1.jpg)

І впишемо зміни у файл README:

![34.2](screens2/34.2.jpg)

Тепер додамо цю зміну і зробимо коміт:

![34.3](screens2/34.3.jpg)

35. Підтягування змін

Переходимо в репозиторії home:

![35.1](screens2/35.1.jpg)

Команда git fetch буде підтягувати нові коміти з віддаленого репозиторія, але не буде зливати їх з напрацюваннями в локальних гілках:

![35.2](screens2/35.2.jpg)

Клонований файл README не змінився:

![35.3](screens2/35.3.jpg)

36. Злиття підтягнутих змін

Потрібно злити підтягнуті зміни в локальну гілку main:

![36.1](screens2/36.1.jpg)

Ще раз перевіряємо файл README:

![36.2](screens2/36.2.jpg)

Ось зміни. Хоча команда git fetch не зливає зміни, можна вручну злити зміни з віддаленого репозиторія.

Для зручності існує також команда pull, яка підтягує та зливає зміни з віддаленої гілки у поточну гілку одним викликом:

![36.3](screens2/36.3.jpg)

37. Додавання гілки відстеження

Додамо локальну гілку, котра відстежує віддалену гілку:

![37.1](screens2/37.1.jpg)

Тепер видно гілку style у списку гілок і у лозі.

38. Чисті репозиторії

Створимо чистий репозиторій:

![38.1](screens2/38.1.jpg)

Зазвичай вважається, що репозиторії, які закінчуються на .git, є чистими репозиторіями. Тут видно, що у репозиторії work.git немає робочих файлів. По суті, це просто директорія .git зі звичайного репозиторія.

39. Додавання віддаленого репозиторія

Додамо репозиторій work.git до оригінального репозиторія:

![39.1](screens2/39.1.jpg)

40. Відправка змін

Змінемо вміст файла README і зробимо коміт змін:

![40.1](screens2/40.1.jpg)

![40.2](screens2/40.2.jpg)

Тепер треба надіслати зміни до спільного репозиторія:

![40.3](screens2/40.3.jpg)

41. Підтягування спільних змін

Перейдемо в репозиторій home і підтягнемо зміни, щойно відправлені в спільний репозиторій:

![41.1](screens2/41.1.jpg)

git remote add shared ../work.git - після виконання цієї команди в локальному репозиторії буде налаштований новий віддалений репозиторій з ім'ям shared, який посилається на репозиторій за адресою ../work.git.

git branch --track shared main - буде локальна гілка shared, яка автоматично відстежує гілку main з віддаленого репозиторію shared.

git pull shared main - зміни з гілки main у віддаленому репозиторії shared будуть отримані та об'єднані з поточною локальною гілкою.

cat README – і переглядаємо вміст файлу README.

